import { Stage, Round, Match, MatchGame, Id } from 'brackets-model';
import { Database, FinalStandingsItem, ParticipantSlot } from './types';
import { BaseGetter } from './base/getter';
export declare class Get extends BaseGetter {
    /**
     * Returns the data needed to display a stage.
     *
     * @param stageId ID of the stage.
     */
    stageData(stageId: Id): Promise<Database>;
    /**
     * Returns the data needed to display a whole tournament with all its stages.
     *
     * @param tournamentId ID of the tournament.
     */
    tournamentData(tournamentId: Id): Promise<Database>;
    /**
     * Returns the match games associated to a list of matches.
     *
     * @param matches A list of matches.
     */
    matchGames(matches: Match[]): Promise<MatchGame[]>;
    /**
     * Returns the stage that is not completed yet, because of uncompleted matches.
     * If all matches are completed in this tournament, there is no "current stage", so `null` is returned.
     *
     * @param tournamentId ID of the tournament.
     */
    currentStage(tournamentId: Id): Promise<Stage | null>;
    /**
     * Returns the round that is not completed yet, because of uncompleted matches.
     * If all matches are completed in this stage of a tournament, there is no "current round", so `null` is returned.
     *
     * Note: The consolation final of single elimination and the grand final of double elimination will be in a different `Group`.
     *
     * @param stageId ID of the stage.
     * @example
     * If you don't know the stage id, you can first get the current stage.
     * ```js
     * const tournamentId = 3;
     * const currentStage = await manager.get.currentStage(tournamentId);
     * const currentRound = await manager.get.currentRound(currentStage.id);
     * ```
     */
    currentRound(stageId: Id): Promise<Round | null>;
    /**
     * Returns the matches that can currently be played in parallel.
     * If the stage doesn't contain any, an empty array is returned.
     *
     * Note:
     * - Returned matches are ongoing (i.e. ready or running).
     * - Returned matches can be from different rounds.
     *
     * @param stageId ID of the stage.
     * @example
     * If you don't know the stage id, you can first get the current stage.
     * ```js
     * const tournamentId = 3;
     * const currentStage = await manager.get.currentStage(tournamentId);
     * const currentMatches = await manager.get.currentMatches(currentStage.id);
     * ```
     */
    currentMatches(stageId: Id): Promise<Match[]>;
    /**
     * Returns the seeding of a stage.
     *
     * @param stageId ID of the stage.
     */
    seeding(stageId: Id): Promise<ParticipantSlot[]>;
    /**
     * Returns the final standings of a stage.
     *
     * @param stageId ID of the stage.
     */
    finalStandings(stageId: Id): Promise<FinalStandingsItem[]>;
    /**
     * Returns the seeding of a round-robin stage.
     *
     * @param stage The stage.
     */
    private roundRobinSeeding;
    /**
     * Returns the seeding of an elimination stage.
     *
     * @param stage The stage.
     */
    private eliminationSeeding;
    /**
     * Returns the final standings of a single elimination stage.
     *
     * @param stageId ID of the stage.
     */
    private singleEliminationStandings;
    /**
     * Returns the final standings of a double elimination stage.
     *
     * @param stageId ID of the stage.
     */
    private doubleEliminationStandings;
    /**
     * Returns only the data specific to the given stage (without the participants).
     *
     * @param stageId ID of the stage.
     */
    private getStageSpecificData;
}
//# sourceMappingURL=get.d.ts.map