import { Match, MatchGame, Seeding, Stage, GroupType, Id, IdSeeding } from 'brackets-model';
import { DeepPartial, ParticipantSlot, Side } from '../types';
import { SetNextOpponent } from '../helpers';
import { BaseGetter } from './getter';
export declare class BaseUpdater extends BaseGetter {
    /**
     * Updates or resets the seeding of a stage.
     *
     * @param stageId ID of the stage.
     * @param seeding A new seeding or `null` to reset the existing seeding.
     * @param seeding.seeding Can contain names, IDs or BYEs.
     * @param seeding.seedingIds Can only contain IDs or BYEs.
     * @param keepSameSize Whether to keep the same size as before for the stage.
     */
    protected updateSeeding(stageId: Id, { seeding, seedingIds }: {
        seeding?: Seeding | null;
        seedingIds?: IdSeeding | null;
    }, keepSameSize: boolean): Promise<void>;
    /**
     * Confirms the current seeding of a stage.
     *
     * @param stageId ID of the stage.
     */
    protected confirmCurrentSeeding(stageId: Id): Promise<void>;
    /**
     * Updates a parent match based on its child games.
     *
     * @param parentId ID of the parent match.
     * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.
     */
    protected updateParentMatch(parentId: Id, inRoundRobin: boolean): Promise<void>;
    /**
     * Throws an error if a match is locked and the new seeding will change this match's participants.
     *
     * @param matches The matches stored in the database.
     * @param slots The slots to check from the new seeding.
     */
    protected static assertCanUpdateSeeding(matches: Match[], slots: ParticipantSlot[]): void;
    /**
     * Updates the matches related (previous and next) to a match.
     *
     * @param match A match.
     * @param updatePrevious Whether to update the previous matches.
     * @param updateNext Whether to update the next matches.
     */
    protected updateRelatedMatches(match: Match, updatePrevious: boolean, updateNext: boolean): Promise<void>;
    /**
     * Updates a match based on a partial match.
     *
     * @param stored A reference to what will be updated in the storage.
     * @param match Input of the update.
     * @param force Whether to force update locked matches.
     */
    protected updateMatch(stored: Match, match: DeepPartial<Match>, force?: boolean): Promise<void>;
    /**
     * Updates a match game based on a partial match game.
     *
     * @param stored A reference to what will be updated in the storage.
     * @param game Input of the update.
     */
    protected updateMatchGame(stored: MatchGame, game: DeepPartial<MatchGame>): Promise<void>;
    /**
     * Updates the opponents and status of a match and its child games.
     *
     * @param match A match.
     */
    protected applyMatchUpdate(match: Match): Promise<void>;
    /**
     * Updates the match(es) leading to the current match based on this match results.
     *
     * @param match Input of the update.
     * @param matchLocation Location of the current match.
     * @param stage The parent stage.
     * @param roundNumber Number of the round.
     */
    protected updatePrevious(match: Match, matchLocation: GroupType, stage: Stage, roundNumber: number): Promise<void>;
    /**
     * Sets the status of a list of matches to archived.
     *
     * @param matches The matches to update.
     */
    protected archiveMatches(matches: Match[]): Promise<void>;
    /**
     * Resets the status of a list of matches to what it should currently be.
     *
     * @param matches The matches to update.
     */
    protected resetMatchesStatus(matches: Match[]): Promise<void>;
    /**
     * Updates the match(es) following the current match based on this match results.
     *
     * @param match Input of the update.
     * @param matchLocation Location of the current match.
     * @param stage The parent stage.
     * @param roundNumber Number of the round.
     * @param roundCount Count of rounds.
     */
    protected updateNext(match: Match, matchLocation: GroupType, stage: Stage, roundNumber: number, roundCount: number): Promise<void>;
    /**
     * Applies a `SetNextOpponent` function to matches following the current match.
     *
     * - `nextMatches[0]` is assumed to be next match for the winner of the current match.
     * - `nextMatches[1]` is assumed to be next match for the loser of the current match.
     *
     * @param setNextOpponent The `SetNextOpponent` function.
     * @param match The current match.
     * @param matchLocation Location of the current match.
     * @param roundNumber Number of the current round.
     * @param roundCount Count of rounds.
     * @param nextMatches The matches following the current match.
     * @param winnerSide Side of the winner in the current match.
     */
    protected applyToNextMatches(setNextOpponent: SetNextOpponent, match: Match, matchLocation: GroupType, roundNumber: number, roundCount: number, nextMatches: (Match | null)[], winnerSide?: Side): Promise<void>;
    /**
     * Propagates winner against BYEs in related matches.
     *
     * @param match The current match.
     */
    protected propagateByeWinners(match: Match): Promise<void>;
}
//# sourceMappingURL=updater.d.ts.map